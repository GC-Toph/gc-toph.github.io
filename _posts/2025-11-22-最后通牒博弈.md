---
title: 最后通牒博弈
date: 2025-11-22 00:01:00 +0800
last_modified_at: 2025-11-23 00:02:00 +0800
categories: [博弈论] # 最多两层
tags: [博弈论, 演化]
math: true
# toc: false # 关闭目录
---


## 最后通牒博弈

**最后通牒博弈**（Ultimatum Game）是行为经济学中的经典实验：  
- 一人（Proposer）被给予一笔固定金额（如10元），决定如何分配给自己和对方；
- 另一人（Responder）可选择接受或拒绝该分配；
- 若接受，双方按方案获得金钱；若拒绝，双方都一无所获。

传统模型预测：Proposer 应只给对方1元（因 Responder 应接受任何正收益），但现实中人们常拒绝不公平分配，表现出**公平偏好**与**惩罚意愿**。


## 棋盘

### 生态系统
- **Proposer**：每次分配10元，自留 **x** 元（x ∈ {1,2,…,9}），给予对方 (10−x) 元。
- **Responder**：设定最低接受额 **y** 元（y ∈ {1,2,…,9}），仅当收到 ≥ y 时才接受。

**互动合作是生存基础**：没有对方，个体无法获得金钱或完成交易。

### 机会均等

- 所有个体起始 **生命值(机会数) = 100**，**金钱 = 0**；
- 每次互动（无论成功与否）**消耗1点生命值**；
- 生命值归零 → **退出本轮游戏**。

### 自由选择

每轮从所有**存活个体中随机配对**，无人优先、无人被排除；

- 若 $10−x \geq y$：合作成功 → **最多连续交易10次**（或至某方生命耗尽）；
- 否则：合作失败 → **双方无收入**。双方**不会长期绑定**，立刻参与下一轮随机配对；

### 代际演化（自然选择, 适者生存）

每代结束后：
- 按**总赚钱数**衡量**适应度**；
- 群体规模恒定：各角色1000人，共2000个体。
- 分别**淘汰最穷的20人**；
- 分别**复制最富的20人**的策略（x 或 y）, 新一代**重置生命值=100，金钱=0**；
- 演化 **100代**。


> 注：当前模型**未包含突变**，演化完全依赖选择压力与初始多样性。


## 代码

```python
# pip install matplotlib

import random
import matplotlib.pyplot as plt

# 全局配置
NUM_AGENTS = 1000  # 每种角色的数量
INITIAL_HP = 100
ROUNDS_PER_SUCCESS = 10
TOTAL_GENERATIONS = 100  # 模拟多少代
NUM_ELIMINATED = 20  # 每代淘汰（并复制）的个体数量


class Proposer:
    def __init__(self, id, x=None):
        self.id = id
        # x: Amount kept for self (1-9), so offer to responder is 10-x
        self.x = x if x is not None else random.randint(1, 9)
        self.hp = INITIAL_HP
        self.money = 0

    def reset_status(self):
        self.hp = INITIAL_HP
        self.money = 0


class Responder:
    def __init__(self, id, y=None):
        self.id = id
        # y: Minimum amount acceptable (1-9)
        self.y = y if y is not None else random.randint(1, 9)
        self.hp = INITIAL_HP
        self.money = 0

    def reset_status(self):
        self.hp = INITIAL_HP
        self.money = 0


def run_market_session(proposers, responders):
    """
    Run one generation of market interaction until HP runs out.
    """
    while True:
        active_proposers = [a for a in proposers if a.hp > 0]
        active_responders = [p for p in responders if p.hp > 0]

        if not active_proposers or not active_responders:
            break

        random.shuffle(active_proposers)
        random.shuffle(active_responders)

        num_pairs = min(len(active_proposers), len(active_responders))

        for i in range(num_pairs):
            proposer = active_proposers[i]
            responder = active_responders[i]

            offer_to_responder = 10 - proposer.x
            min_accept = responder.y

            if offer_to_responder >= min_accept:
                # Collaboration success
                rounds = min(ROUNDS_PER_SUCCESS, proposer.hp, responder.hp)
                proposer.money += proposer.x * rounds
                responder.money += offer_to_responder * rounds
                proposer.hp -= rounds
                responder.hp -= rounds
            else:
                # Collaboration failed
                proposer.hp -= 1
                responder.hp -= 1


def evolve_population(agents, role_name):
    """
    Evolution: eliminate the poorest, replicate the richest.
    """
    agents.sort(key=lambda agent: agent.money, reverse=True)

    top_n = agents[:NUM_ELIMINATED]
    survivors = agents[: NUM_AGENTS - NUM_ELIMINATED]

    new_agents = []
    current_id_max = max(a.id for a in agents)

    for i, parent in enumerate(top_n):
        if role_name == "Proposer":
            child = Proposer(current_id_max + i + 1, x=parent.x)
        else:
            child = Responder(current_id_max + i + 1, y=parent.y)
        new_agents.append(child)

    next_generation = survivors + new_agents

    for agent in next_generation:
        agent.reset_status()

    return next_generation


def plot_evolution(history, title, filename, legend_labels):
    """
    Draw stacked area chart with high contrast colors and English labels.
    """
    generations = range(len(history))
    strategies = range(1, 10)  # Values 1 to 9
    
    # Prepare data stack
    y_stack = []
    for s in strategies:
        counts = [gen_data.get(s, 0) for gen_data in history]
        y_stack.append(counts)

    plt.figure(figsize=(12, 6))
    
    # Use 'tab10' colormap which provides distinct colors for categorical data
    # 'tab10' has 10 colors, we need 9.
    cmap = plt.get_cmap('tab10')
    colors = [cmap(i) for i in range(9)]
    
    plt.stackplot(generations, y_stack, labels=legend_labels, colors=colors, alpha=0.9)
    
    plt.title(title, fontsize=14)
    plt.xlabel("Generation", fontsize=12)
    plt.ylabel("Number of Agents", fontsize=12)
    plt.xlim(0, len(history)-1)
    plt.ylim(0, NUM_AGENTS)
    
    # Legend outside the plot
    plt.legend(loc='upper left', bbox_to_anchor=(1, 1), title="Strategy Value")
    plt.tight_layout()
    
    print(f"Saving plot: {filename} ...")
    plt.savefig(filename)
    plt.close()


def main():
    proposers = [Proposer(i) for i in range(NUM_AGENTS)]
    responders = [Responder(i) for i in range(NUM_AGENTS)]

    proposer_history = []
    responder_history = []

    # Record Generation 0
    p_counts = {k: 0 for k in range(1, 10)}
    for a in proposers: p_counts[a.x] = p_counts.get(a.x, 0) + 1
    proposer_history.append(p_counts)

    r_counts = {k: 0 for k in range(1, 10)}
    for a in responders: r_counts[a.y] = r_counts.get(a.y, 0) + 1
    responder_history.append(r_counts)

    for gen in range(1, TOTAL_GENERATIONS + 1):
        run_market_session(proposers, responders)

        proposers = evolve_population(proposers, "Proposer")
        responders = evolve_population(responders, "Responder")

        # Collect data
        current_p_counts = {k: 0 for k in range(1, 10)}
        for a in proposers:
            current_p_counts[a.x] = current_p_counts.get(a.x, 0) + 1
        proposer_history.append(current_p_counts)

        current_r_counts = {k: 0 for k in range(1, 10)}
        for a in responders:
            current_r_counts[a.y] = current_r_counts.get(a.y, 0) + 1
        responder_history.append(current_r_counts)

    #  Simulation Ended, Plotting...

    # Labels for legend
    p_labels = [f"Keep ${i} (Give ${10-i})" for i in range(1, 10)]
    r_labels = [f"Demand Min ${i}" for i in range(1, 10)]

    # Plot Proposer
    plot_evolution(
        proposer_history, 
        title="Evolution of Proposer Strategies (x = Money Kept)", 
        filename="proposer_evolution.png",
        legend_labels=p_labels
    )

    # Plot Responder
    plot_evolution(
        responder_history, 
        title="Evolution of Responder Strategies (y = Min Accept)", 
        filename="responder_evolution.png",
        legend_labels=r_labels
    )

    print("\n最终Proposer分布 (x值: 自留金额):")
    final_p = proposer_history[-1]
    for x in sorted(final_p.keys()):
        if final_p[x] > 0:
            print(f"  自留 ${x} (给 ${10-x}): {final_p[x]} 人")

    print("\n最终Responder分布 (y值: 最低要求):")
    final_r = responder_history[-1]
    for y in sorted(final_r.keys()):
        if final_r[y] > 0:
            print(f"  要求 ${y}: {final_r[y]} 人")

if __name__ == "__main__":
    main()
```

## 运行结果

```text
最终Proposer分布 (x值: 自留金额):
  自留 $7 (给 $3): 1000 人

最终Responder分布 (y值: 最低要求):
  要求 $1: 273 人
  要求 $2: 351 人
  要求 $3: 376 人
```

![proposer_evolution](/assets/images/20251122/proposer_evolution.png)

![responder_evolution](/assets/images/20251122/responder_evolution.png)


结论：中期**六四分成**；长期**七三分成**。

> 主要看Proposer分布，尽管Responder 要求1元，实际每次合作也是获得3元。

![warning](/assets/images/warning.jpg)
